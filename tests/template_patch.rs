/*
 * Copyright (2020) by Marcel Lambert.
 * This project's License is the MIT Open Source license.
 * For more information, see the LICENSE.md file in this repository.
 */

#![deny(missing_docs)]

mod template_partial;
use derive_patch::{
    diff::{CopyDiff, Diff, NumericDistanceDiff},
    mismatch::{MismatchError, MismatchType, MultipleMismatchError},
    traits::{Base, Patch, PatchableExt},
};
use template_partial::PartialExample;

#[derive(Debug)]
pub struct Example {
    // #[diff = NumericDistanceDiff]
    food: f64,
    bard: Option<String>,

    // #[nonPatchable]
    something_special: u32,

    // #[patchid]
    id: String,
    /*todo: allow for fields that are present in the patch but not in the original `Example``
     * e.g. for Timestamp, patch_id */
}
impl Example {
    pub fn use_all_vars(&self) -> String {
        format!("{}", self.something_special)
    }
}

// Here starts the autogenerated parts

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

impl PatchableExt for Example {}

#[derive(PartialEq, Debug, Clone)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ExamplePatch {
    food: Option<NumericDistanceDiff<f64>>,
    bard: Option<CopyDiff<Option<String>>>,

    id: String,
}

impl ExamplePatch {
    pub fn new(id: String) -> ExamplePatch {
        ExamplePatch {
            id,
            food: None,
            bard: None,
        }
    }

    pub fn new_with_partial(
        obj: &Example,
        partial: &PartialExample,
        id: String, /* all patchid attributes */
    ) -> ExamplePatch {
        let food = match partial.food {
            Some(food) => {
                let diff = NumericDistanceDiff::new(&obj.food, &food);
                if diff.contains_change() {
                    Some(diff)
                } else {
                    None
                }
            }
            None => None,
        };

        let bard = match &partial.bard {
            Some(bard) => {
                let diff = CopyDiff::new(&obj.bard, &bard);

                if diff.contains_change() {
                    Some(diff)
                } else {
                    None
                }
            }
            None => None,
        };

        ExamplePatch { id, food, bard }
    }

    /// internal apply function. Responsible for actually assigning the values.
    ///
    /// This function performs no checks, it's the responsibility of the caller
    /// to perform checks.
    ///
    /// Used by `apply` and `force_apply`
    fn _apply(&self, obj: &mut Example) {
        // apply the patch
        if let Some(food) = &self.food {
            let _ = food.apply_into(&mut obj.food);
        }
        if let Some(bard) = &self.bard {
            let _ = bard.apply_into(&mut obj.bard);
        }
    }
}
impl Base<Result<(), MultipleMismatchError>> for ExamplePatch {
    type Target = Example;

    /// Available fields
    /// - `food`
    /// - `bard`
    const MAX_FIELDS: usize = 2;

    /// returns true if ALL fields have an associated diff.
    fn is_complete(&self) -> bool {
        self.food.is_some() && self.bard.is_some()
    }

    fn is_empty(&self) -> bool {
        self.food.is_none() && self.bard.is_none()
    }

    fn count(&self) -> u32 {
        let mut count = 0;
        //for each attribute
        if self.food.is_some() {
            count += 1;
        }

        if self.bard.is_some() {
            count += 1;
        }

        count
    }

    /// applies the patch to the given object
    ///
    /// makes sure the `id` of `Example` matches the `id` field of this Patch.
    /// Returns an Error if that is not the case.
    ///
    /// makes sure that all old_values of the patches field are the current
    /// value of the given example. Returns an Error otherwise.
    ///
    /// This function does not change `obj` if an Error occurs.
    fn apply(&self, obj: &mut Example) -> Result<(), MultipleMismatchError> {
        if let Err(e) = self.is_correct_target(obj) {
            return Err(e);
        }

        if let Err(e) = self.can_apply_cleanly(obj) {
            return Err(e);
        }

        self._apply(obj);

        Ok(())
    }
}

impl Patch for ExamplePatch {
    ///todo: adds changes from this patch ontop of the given patch.
    //fn merge_into(&self, obj: &mut ExamplePatch) -> Result<(), ()> {
    //    Ok(()) //TODO:
    //}

    ///todo: overwrites the changes in the given patch
    //fn overwrite_into() {}

    //todo: keeps all the new values, but sets the old values from the current obj
    //fn rebase(&mut self, obj: &Example) {}

    fn cleanup(&mut self) -> bool {
        let mut changed = false;
        if let Some(food) = &self.food {
            if !food.contains_change() {
                self.food = None;
                changed = true;
            }
        }

        if let Some(bard) = &self.bard {
            if !bard.contains_change() {
                self.bard = None;
                changed = true;
            }
        }

        changed
    }

    fn is_correct_target(&self, obj: &Self::Target) -> Result<(), MultipleMismatchError> {
        let mut error = MultipleMismatchError::new();

        //check all id types
        if self.id != obj.id {
            error.add_error(MismatchError::new(
                "id",
                format!("{:?}", obj.id),
                format!("{:?}", self.id),
                MismatchType::ObjectID,
            ));
        }

        if error.is_error_free() {
            Ok(())
        } else {
            Err(error)
        }
    }

    fn can_apply_cleanly(&self, obj: &Self::Target) -> Result<(), MultipleMismatchError> {
        let mut error = MultipleMismatchError::new();

        //check all old values match
        if let Some(food) = &self.food {
            if let Err(e) = food.applies_cleanly(&obj.food) {
                error.add_error(e);
            }
        }
        if let Some(bard) = &self.bard {
            if let Err(e) = bard.applies_cleanly(&obj.bard) {
                error.add_error(e);
            }
        }

        if error.is_error_free() {
            Ok(())
        } else {
            Err(error)
        }
    }

    //check that all id fields are the same
    fn is_same_target(&self, other: &Self) -> bool {
        //for all id fields
        self.id == other.id
    }
}
